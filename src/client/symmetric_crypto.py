# https://cryptobook.nakov.com/symmetric-key-ciphers/aes-encrypt-decrypt-examples
# https://stackoverflow.com/questions/65230554/cannot-decode-encrypted-rsa-message-python3

import base64
import binascii
import os
import pyaes
import secrets
from asymmetric_crypto import rsa_encrypt_with_peer_public_key, rsa_decrypt_b64_with_private_key

# This file contains functions for AES keys management as well as encryption and decryption processes.


def byte_to_base64_string(byte_message):
    """
    This function is essential to store data in the database : the .JSON file use by TinyDB doesn't allows to store
    'bytes' : a prior conversion is needed. This conversion is done here.
    """
    byte_message_b64 = base64.b64encode(byte_message)
    return byte_message_b64.decode()


def base64_string_to_byte(b64_string):
    """
    This function is essential to store data in the database : the .JSON file use by TinyDB doesn't allows to store
    'bytes' : a prior conversion is needed. This conversion is done here.
    """
    encoded_b64 = b64_string.encode()
    return base64.b64decode(encoded_b64)


def initialize_personal_aes_key(conversation_id):
    """
    The initialization vector (IV) is assumed to be part of the specification of the CTR mode used with the AES
    encryption. This IV value is constant and known by any new client (i.e the value is stored locally by default).
    The AES key is randomly generated. A new AES key will be created for each new conversation that include the user:
    for this reason, the AES key is stored locally by using the 'conversation_id' in the key's filename.
    """
    key = os.urandom(32)
    key_b64_string = byte_to_base64_string(key)
    # iv_string = secrets.randbits(256)
    if not os.path.exists("./keys"):
        os.mkdir("./keys")
    with open(f'keys/private_AES_{conversation_id}.pem', "w") as file:
        file.write(key_b64_string)


def get_AES_secret_key(conversation_id):
    if not os.path.exists(f'keys/private_AES_{conversation_id}.pem'):
        initialize_personal_aes_key(conversation_id)
    f1 = open(f'keys/private_AES_{conversation_id}.pem', "r")
    f2 = open(f'keys/CTR_IV.txt')

    aes_key = f1.read()
    iv_string = f2.read()
    return base64_string_to_byte(aes_key), int(iv_string)


def encryption_using_AES_key(plaintext, conversation_id):
    aes_key, iv = get_AES_secret_key(conversation_id)
    aes = pyaes.AESModeOfOperationCTR(aes_key, pyaes.Counter(iv))
    ciphertext = aes.encrypt(plaintext)
    return ciphertext


def decryption_using_AES_key(ciphertext, conversation_id):
    aes_key, iv = get_AES_secret_key(conversation_id)
    aes = pyaes.AESModeOfOperationCTR(aes_key, pyaes.Counter(iv))
    plaintext = aes.decrypt(ciphertext)
    return plaintext


def check_for_existing_local_key(conversation_id, encr_aes_key):
    """
    This function is used by the client that doesn't initiate itself a new conversation : for this client,
    the AES key is not yet generated. This AES key will be generated based on the encrypted AES key received from
    the server : this encrypted key was created by the other user during the creation of the new conversation.
    The other user used to current user RSA public key to encrypt the AES key : the current user only needs to
    use his RSA private key to know the AES key generated by the other user.
    """
    if not os.path.exists(f'keys/private_AES_{conversation_id}.pem'):
        new_secret_aes_key = rsa_decrypt_b64_with_private_key(encr_aes_key)
        with open(f'keys/private_AES_{conversation_id}.pem', "w") as file:
            file.write(new_secret_aes_key)


def create_encrypted_symmetric_key(rsa_public_key, conversation_id):
    """
    Called by the client that create a new conversation. This client uses his peer RSA public key to encrypt the
    AES key that will be used to encrypt the messages.
    """
    base64_key, iv_string = get_AES_secret_key(conversation_id)
    aes_key = byte_to_base64_string(base64_key)
    encrypted_aes_key = rsa_encrypt_with_peer_public_key(rsa_public_key, aes_key)
    return encrypted_aes_key

